<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>九九乘法冒險島</title>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@700&display=swap" rel="stylesheet"/>
  <style>
    :root { --safe-bottom: env(safe-area-inset-bottom, 0px); }
    body { margin:0; overflow:hidden; background:#87ceeb; font-family:'M PLUS Rounded 1c', sans-serif; }
    canvas { display:block; }

    /* 覆蓋在 Canvas 上方的真實輸入框（enterName 時顯示） */
    #nameInput {
      position: fixed; /* 直接定位在視窗上，避免因捲動偏移 */
      display: none;   /* 預設不顯示，進入輸入頁才顯示 */
      border: 2px solid #CCC;
      border-radius: 10px;
      background: #FFF;
      color: #000;
      font-weight: 700;
      text-align: center;
      outline: none;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      z-index: 10;     /* 高於 Canvas */
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <!-- ★ 真實輸入框（平板會叫出軟鍵盤） -->
  <input id="nameInput" type="text" inputmode="text" autocomplete="off" autocapitalize="none" maxlength="10" placeholder="請在此輸入名字" />

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, collection, addDoc, getDocs, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const nameInputEl = document.getElementById('nameInput');

    /* ========= 圓角矩形 polyfill ========= */
    function rr(ctx, x, y, w, h, r = 0) {
      const radii = typeof r === 'number' ? {tl:r, tr:r, br:r, bl:r} : (r || {tl:0,tr:0,bl:0});
      ctx.beginPath();
      ctx.moveTo(x + radii.tl, y);
      ctx.lineTo(x + w - radii.tr, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radii.tr);
      ctx.lineTo(x + w, y + h - radii.br);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radii.br, y + h);
      ctx.lineTo(x + radii.bl, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radii.bl);
      ctx.lineTo(x, y + radii.tl);
      ctx.quadraticCurveTo(x, y, x + radii.tl, y);
    }

    function getSafeBottom() {
      const v = getComputedStyle(document.documentElement).getPropertyValue('--safe-bottom') || '0px';
      const n = parseFloat(v);
      return isNaN(n) ? 0 : n;
    }

    /* ========= Firebase ========= */
    let db, auth;
    async function initializeFirebase() {
      try {
        const firebaseConfig = {
          apiKey: "AIzaSyDfIw36T88S3xlGCoAP9nDGCRkpQlWKiLE",
          authDomain: "ieka99.firebaseapp.com",
          projectId: "ieka99",
          storageBucket: "ieka99.appspot.com",
          messagingSenderId: "893665009867",
          appId: "1:893665009867:web:d732e15cf792890c8a7b4e"
        };
        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);
        setLogLevel('error');
        await signInAnonymously(auth).catch(()=>{ db = null; });
      } catch { db = null; }
    }

    /* ========= 狀態 ========= */
    let currentPage = 'home';
    let currentQuestion = {};
    let feedbackMessage = '';
    let correctAnswersCount = 0;
    let score = 0;
    let answerButtons = [];
    let uiButtons = [];
    let questionRange = 0;
    let lastQuestion = {};
    let playerName = '';
    let leaderboardData = [];
    let isLeaderboardLoading = false;
    let isAnswerLocked = false;

    // 動畫/計時
    let characterYOffset = 0;
    let isCharacterJumping = false;
    let jumpStartTime = 0;
    const JUMP_DURATION = 1000, JUMP_HEIGHT = 50;
    let feedbackEndTime = 0, lastAnswerWasCorrect = false;
    let startTime = 0, elapsedTime = 0;

    // 音效
    let correctSynth, wrongSynth, clickSynth;
    let audioInitialized = false;

    // 圖片
    let akitaImage, characterImage;

    function loadAssets() {
      return new Promise((resolve, reject) => {
        akitaImage = new Image();
        characterImage = new Image();
        akitaImage.src = '可愛秋田.png';
        characterImage.src = 'S876553.png';
        let loaded = 0;
        const done=()=>{ if(++loaded===2) resolve(); };
        akitaImage.onload = done; characterImage.onload = done;
        akitaImage.onerror = ()=>reject(new Error('akita load fail'));
        characterImage.onerror = ()=>reject(new Error('character load fail'));
        setTimeout(()=>reject(new Error('image timeout')), 8000);
      });
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      // 進入輸入頁時，重新定位覆蓋輸入框
      if (currentPage === 'enterName') positionNameInput();
    }

    function drawText(text, x, y, fontSize, color, align='center', baseline='middle') {
      ctx.font = `bold ${fontSize}px 'M PLUS Rounded 1c', sans-serif`;
      ctx.fillStyle = color;
      ctx.textAlign = align;
      ctx.textBaseline = baseline;
      ctx.shadowColor = 'rgba(0,0,0,0.2)';
      ctx.shadowBlur = 5; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2;
      ctx.fillText(text, x, y);
      ctx.shadowColor = 'transparent';
    }

    function drawSystemText(text, color='#333') {
      ctx.fillStyle="#fff"; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.font="bold 30px sans-serif"; ctx.fillStyle=color;
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(text, canvas.width/2, canvas.height/2);
    }

    function drawHomePage() {
      const g=ctx.createLinearGradient(0,0,0,canvas.height);
      g.addColorStop(0,'#87CEEB'); g.addColorStop(1,'#66CDAA');
      ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
      drawCloud(150,100,1); drawCloud(canvas.width-200,150,0.8);
      drawText('王公九九乘法冒險島', canvas.width/2, canvas.height*0.25, canvas.width>600?50:36, '#000080');
      drawText('等你來挑戰！', canvas.width/2, canvas.height*0.35, canvas.width>600?24:18, '#000080');

      if (characterImage && characterImage.complete && characterImage.naturalWidth>0) {
        const w = canvas.width*0.15, h = (characterImage.naturalHeight/characterImage.naturalWidth)*w;
        ctx.drawImage(characterImage, canvas.width/2 - w/2, canvas.height/2 - h/2, w, h);
      }

      const bw=220,bh=70, y1=canvas.height*0.7, y2=y1+bh+20;
      drawButton('開始冒險！', canvas.width/2, y1, bw, bh, '#FF69B4', '#FFFFFF');
      drawButton('排行榜', canvas.width/2, y2, bw, bh, '#17a2b8', '#FFFFFF');
      uiButtons = [
        {id:'start', x:canvas.width/2, y:y1, width:bw, height:bh},
        {id:'show_leaderboard', x:canvas.width/2, y:y2, width:bw, height:bh}
      ];
      hideNameInput(); // 回首頁時確保隱藏
    }

    function drawCloud(x,y,s) {
      ctx.fillStyle='rgba(255,255,255,0.9)';
      ctx.beginPath(); ctx.arc(x,y,30*s,0,Math.PI*2);
      ctx.arc(x+35*s,y-10*s,40*s,0,Math.PI*2);
      ctx.arc(x+70*s,y,30*s,0,Math.PI*2);
      ctx.arc(x+35*s,y+15*s,40*s,0,Math.PI*2);
      ctx.closePath(); ctx.fill();
    }

    function drawSelectionPage() {
      const g=ctx.createLinearGradient(0,0,0,canvas.height);
      g.addColorStop(0,'#9ACD32'); g.addColorStop(1,'#FFD700');
      ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
      drawText('選擇你的乘法挑戰！', canvas.width/2, canvas.height*0.1, canvas.width>600?40:28, '#8B4513');

      uiButtons = [];
      const nums = [1,2,3,4,5,6,7,8,9,10,'混合'];
      const cols = canvas.width>800?4:3;
      const bw = Math.floor((canvas.width*0.8)/cols);
      const bh = 60;
      const spacingX = bw + 20, spacingY = bh + 20;
      const startX = (canvas.width - (cols*spacingX - 20))/2 + bw/2;
      const startY = canvas.height*0.25;

      nums.forEach((num, i)=>{
        const r = Math.floor(i/cols), c = i%cols;
        const x = startX + c*spacingX;
        const y = startY + r*spacingY;
        const label = (num==='混合') ? '混合' : `${num} 的乘法`;
        drawButton(label, x, y, bw, bh, '#4CAF50', '#FFFFFF');
        uiButtons.push({ id:'select', value:num, x, y, width:bw, height:bh });
      });
      hideNameInput();
    }

    function drawPracticePage() {
      const g=ctx.createLinearGradient(0,0,0,canvas.height);
      g.addColorStop(0,'#1E90FF'); g.addColorStop(1,'#87CEFA');
      ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);

      const bx=canvas.width/2, by=canvas.height*0.2, br=canvas.width>600?100:70;
      ctx.fillStyle='rgba(255,255,255,0.8)';
      ctx.beginPath(); ctx.arc(bx,by,br,0,Math.PI*2); ctx.fill();

      drawText(`${currentQuestion.num1} x ${currentQuestion.num2} = ?`, bx,by, canvas.width>600?48:36, '#000080');
      if (feedbackMessage) drawText(feedbackMessage, canvas.width/2, canvas.height*0.35, canvas.width>600?36:24, '#FF4500');

      drawScore(); drawTime(); drawCharacter();
      drawAnswerButtons();
      drawProgressBar();
      hideNameInput();
    }

    function drawScore(){ drawText(`分數：${score}`, 30, 60, canvas.width>600?24:18, '#FFFFFF','left'); }
    function drawTime(){ const s=Math.floor(elapsedTime/1000); drawText(`時間：${s} 秒`, canvas.width-30, 60, canvas.width>600?24:18, '#FFFFFF','right'); }

    function drawCharacter() {
      const w = canvas.width>600?150:100;
      const nw = (akitaImage&&akitaImage.naturalWidth)||0;
      const nh = (akitaImage&&akitaImage.naturalHeight)||0;
      if (akitaImage && akitaImage.complete && nw>0 && nh>0) {
        const h = (nh/nw)*w;
        ctx.drawImage(akitaImage, canvas.width/2 - w/2, canvas.height*0.45 + characterYOffset - h/2, w, h);
      }
    }

    function drawAnswerButtons() {
      const cols = canvas.width > 700 ? 3 : 2;
      const baseW = 120, baseH = 60, baseGap = 20;
      const rows = Math.ceil(answerButtons.length / cols);
      const barH = 25;
      const safeBottom = getSafeBottom();
      const bottomReserve = safeBottom + barH + 24;
      const availableBottomY = canvas.height - bottomReserve;
      const totalH = rows * baseH + (rows - 1) * baseGap;

      let top = availableBottomY - totalH - 10;
      const minTop = canvas.height * 0.52;

      let s = 1;
      if (top < minTop) {
        const avail = availableBottomY - 10 - minTop;
        const need = totalH;
        s = Math.max(0.6, Math.min(1, avail / need));
        const scaledTotalH = rows * (baseH * s) + (rows - 1) * (baseGap * s);
        top = availableBottomY - scaledTotalH - 10;
      }
      const bw = baseW * s, bh = baseH * s, gap = baseGap * s;
      const totalW = cols * bw + (cols - 1) * gap;
      const startX = (canvas.width - totalW) / 2 + bw / 2;
      const startY = top + bh / 2;

      answerButtons.forEach((btn, i) => {
        const r = Math.floor(i / cols);
        const c = i % cols;
        const x = startX + c * (bw + gap);
        const y = startY + r * (bh + gap);
        drawButton(btn.value, x, y, bw, bh, '#FFD700', '#8B4513');
        btn.x = x; btn.y = y; btn.width = bw; btn.height = bh;
      });
    }

    function drawProgressBar() {
      const barWidth = canvas.width * 0.6;
      const barHeight = 25;
      const safeBottom = getSafeBottom();
      const margin = 10;

      const barX = (canvas.width - barWidth) / 2;
      const barY = canvas.height - safeBottom - margin - barHeight;

      const maxQuestions = 20;
      ctx.fillStyle = '#f0e68c';
      rr(ctx, barX, barY, barWidth, barHeight, 12); ctx.fill();

      const progress = (correctAnswersCount / maxQuestions) * barWidth;
      if (progress > 0) {
        ctx.fillStyle = '#FFC107';
        rr(ctx, barX, barY, progress, barHeight, 12); ctx.fill();
      }

      ctx.strokeStyle = '#daa520';
      ctx.lineWidth = 3;
      rr(ctx, barX, barY, barWidth, barHeight, 12); ctx.stroke();

      drawText(`${correctAnswersCount} / ${maxQuestions}`, canvas.width / 2, barY + barHeight / 2, 16, '#A52A2A');
    }

    function drawGameOverPage() {
      drawPracticePage();
      ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      const mw=canvas.width*0.7, mh=canvas.height*0.6;
      const mx=(canvas.width-mw)/2, my=(canvas.height-mh)/2;
      ctx.fillStyle='#FFF8DC'; ctx.strokeStyle='#F0E68C'; ctx.lineWidth=10;
      rr(ctx,mx,my,mw,mh,20); ctx.fill(); ctx.stroke();
      const totalSec=Math.floor(elapsedTime/1000);
      drawText('挑戰完成！', canvas.width/2, my+mh*0.2, 40,'#D2691E');
      drawText(`總分：${score}`, canvas.width/2, my+mh*0.4, 30,'#8B4513');
      drawText(`總共花了 ${totalSec} 秒`, canvas.width/2, my+mh*0.55, 30,'#8B4513');
      const bw=200,bh=60,bx=canvas.width/2,by=my+mh*0.8;
      drawButton('儲存紀錄', bx,by,bw,bh,'#28a745','#FFFFFF');
      uiButtons=[{id:'save_score', x:bx, y:by, width:bw, height:bh}];
      hideNameInput();
    }

    function drawEnterNamePage() {
      // 底層仍畫出視覺樣式（白框）
      drawGameOverPage();
      ctx.fillStyle='rgba(0,0,0,0.8)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      const mw=canvas.width*0.7, mh=canvas.height*0.5;
      const mx=(canvas.width-mw)/2, my=(canvas.height-mh)/2;
      ctx.fillStyle='#fff'; rr(ctx,mx,my,mw,mh,20); ctx.fill();
      drawText('請輸入你的名字', canvas.width/2, my+mh*0.2, 32, '#333');

      // 輸入框的幾何（和視覺一致）
      const iw=mw*0.8, ih=60, ix=(canvas.width-iw)/2, iy=my+mh*0.4;
      ctx.strokeStyle='#CCC'; ctx.lineWidth=2; rr(ctx,ix,iy,iw,ih,10); ctx.stroke();

      // 不再在 Canvas 上畫名字，改由真實 input 呈現
      const bw=200,bh=60,bx=canvas.width/2,by=my+mh*0.8;
      drawButton('確認', bx,by,bw,bh,'#007bff','#FFFFFF');
      uiButtons=[{id:'confirm_name', x:bx, y:by, width:bw, height:bh}];

      // ★ 顯示與定位真實輸入框
      positionNameInput({ ix, iy, iw, ih });
      showNameInput();
    }

    function drawLeaderboardPage() {
      const g=ctx.createLinearGradient(0,0,0,canvas.height);
      g.addColorStop(0,'#4e54c8');
