<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>王公九九乘法冒險島</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87ceeb;
            font-family: 'M PLUS Rounded 1c', sans-serif;
        }
        canvas {
            display: block;
        }
    </style>
    <!-- Tone.js for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Firebase setup ---
        let db;
        let auth;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        
        async function initializeFirebase() {
            try {
                // *** 重要更新：預留位置現在是一個字串，如果替換失敗，JSON.parse會捕捉到錯誤 ***
                const configStr = '{
  apiKey: "AIzaSyDfIw36T88S3xlGCoAP9nDGCRkpQlWKiLE",
  authDomain: "ieka99.firebaseapp.com",
  projectId: "ieka99",
  storageBucket: "ieka99.firebasestorage.app",
  messagingSenderId: "893665009867",
  appId: "1:893665009867:web:d732e15cf792890c8a7b4e"
}';
                const firebaseConfig = JSON.parse(configStr);

                // 檢查設定物件是否有效
                if (typeof firebaseConfig !== 'object' || !firebaseConfig.apiKey) {
                     console.warn("Firebase config is invalid. Leaderboard will be disabled.");
                     db = null;
                     return;
                }

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('debug');

                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
                console.log("Firebase initialized and user signed in.");
            } catch (e) {
                console.warn("Firebase config is not a valid JSON or not replaced. Leaderboard will be disabled.", e);
                db = null;
            }
        }


        // --- Game State Variables ---
        let currentPage = 'home';
        let currentQuestion = {};
        let feedbackMessage = '';
        let correctAnswersCount = 0;
        let score = 0;
        let answerButtons = [];
        let uiButtons = []; // Generic button array for navigation
        let questionRange = 0;
        let lastQuestion = {};
        let playerName = '';
        let leaderboardData = [];
        let isLeaderboardLoading = false;
        let isAnswerLocked = false; // Lock to prevent multiple answer clicks
        
        // Animation variables
        let characterYOffset = 0;
        let animationFrameId = null;

        // Timer variables
        let startTime = 0;
        let elapsedTime = 0;
        let timerInterval = null;
        
        // --- Audio Synthesis ---
        let correctSynth, wrongSynth, clickSynth;
        let audioInitialized = false;


        // --- Image Loading ---
        let akitaImage, characterImage;

        function loadAssets() {
            return new Promise((resolve, reject) => {
                akitaImage = new Image();
                characterImage = new Image();
                
                akitaImage.src = '可愛秋田.png';
                characterImage.src = 'S876553.png';

                let imagesLoaded = 0;
                const totalImages = 2;

                const onImageLoad = () => {
                    imagesLoaded++;
                    if (imagesLoaded === totalImages) {
                        resolve();
                    }
                };
                
                akitaImage.onload = onImageLoad;
                characterImage.onload = onImageLoad;
                
                akitaImage.onerror = reject;
                characterImage.onerror = reject;
            });
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            drawScreen();
        }

        function drawScreen() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            switch (currentPage) {
                case 'home': drawHomePage(); break;
                case 'selection': drawSelectionPage(); break;
                case 'practice': drawPracticePage(); break;
                case 'gameOver': drawGameOverPage(); break;
                case 'enterName': drawEnterNamePage(); break;
                case 'leaderboard': drawLeaderboardPage(); break;
            }
        }
        
        function drawText(text, x, y, fontSize, color, align = 'center', baseline = 'middle') {
            ctx.font = `bold ${fontSize}px 'M PLUS Rounded 1c', sans-serif`;
            ctx.fillStyle = color;
            ctx.textAlign = align;
            ctx.textBaseline = baseline;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            ctx.fillText(text, x, y);
            ctx.shadowColor = 'transparent';
        }

        // --- New robust function for drawing loading/error messages ---
        function drawSystemText(text, color = '#333') {
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = "bold 30px sans-serif"; // Use a web-safe font
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        }

        function drawHomePage() {
            const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grad.addColorStop(0, '#87CEEB');
            grad.addColorStop(1, '#66CDAA');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawCloud(150, 100, 1);
            drawCloud(canvas.width - 200, 150, 0.8);

            drawText('王公九九乘法冒險島', canvas.width / 2, canvas.height * 0.25, canvas.width > 600 ? 50 : 36, '#000080');
            drawText('等你來挑戰！', canvas.width / 2, canvas.height * 0.35, canvas.width > 600 ? 24 : 18, '#000080');

            if (characterImage && characterImage.complete) {
                const imgWidth = canvas.width * 0.15;
                const imgHeight = (characterImage.height / characterImage.width) * imgWidth;
                ctx.drawImage(characterImage, canvas.width / 2 - imgWidth / 2, canvas.height / 2 - imgHeight / 2, imgWidth, imgHeight);
            }

            const btnWidth = 220;
            const btnHeight = 70;
            const startBtnY = canvas.height * 0.7;
            const rankBtnY = startBtnY + btnHeight + 20;

            drawButton('開始冒險！', canvas.width / 2, startBtnY, btnWidth, btnHeight, '#FF69B4', '#FFFFFF');
            drawButton('排行榜', canvas.width / 2, rankBtnY, btnWidth, btnHeight, '#17a2b8', '#FFFFFF');
            
            uiButtons = [
                { id: 'start', x: canvas.width / 2, y: startBtnY, width: btnWidth, height: btnHeight },
                { id: 'show_leaderboard', x: canvas.width / 2, y: rankBtnY, width: btnWidth, height: btnHeight }
            ];
        }
        
        function drawCloud(x, y, scale) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.arc(x, y, 30 * scale, 0, Math.PI * 2);
            ctx.arc(x + 35 * scale, y - 10 * scale, 40 * scale, 0, Math.PI * 2);
            ctx.arc(x + 70 * scale, y, 30 * scale, 0, Math.PI * 2);
            ctx.arc(x + 35 * scale, y + 15 * scale, 40 * scale, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        }

        function drawSelectionPage() {
            const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grad.addColorStop(0, '#9ACD32');
            grad.addColorStop(1, '#FFD700');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawText('選擇你的乘法挑戰！', canvas.width / 2, canvas.height * 0.1, canvas.width > 600 ? 40 : 28, '#8B4513');
            uiButtons = [];
            const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, '混合'];
            const cols = canvas.width > 800 ? 4 : 3;
            const btnWidth = (canvas.width * 0.8) / cols;
            const btnHeight = 60;
            const spacingX = btnWidth + 20;
            const spacingY = btnHeight + 20;
            const startX = (canvas.width - (cols * spacingX - 20)) / 2 + btnWidth/2;
            const startY = canvas.height * 0.25;
            nums.forEach((num, index) => {
                const row = Math.floor(index / cols);
                const col = index % cols;
                const btnX = startX + col * spacingX;
                const btnY = startY + row * spacingY;
                const label = num === '混合' ? num : `${num} 的乘法`;
                drawButton(label, btnX, btnY, btnWidth, btnHeight, '#4CAF50', '#FFFFFF');
                uiButtons.push({ id: 'select', value: num, x: btnX, y: btnY, width: btnWidth, height: btnHeight });
            });
        }
        
        function drawPracticePage() {
            const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grad.addColorStop(0, '#1E90FF');
            grad.addColorStop(1, '#87CEFA');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            const bubbleX = canvas.width / 2;
            const bubbleY = canvas.height * 0.2;
            const bubbleRadius = canvas.width > 600 ? 100 : 70;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(bubbleX, bubbleY, bubbleRadius, 0, Math.PI * 2);
            ctx.fill();
            drawText(`${currentQuestion.num1} x ${currentQuestion.num2} = ?`, bubbleX, bubbleY, canvas.width > 600 ? 48 : 36, '#000080');
            if (feedbackMessage) {
                drawText(feedbackMessage, canvas.width / 2, canvas.height * 0.35, canvas.width > 600 ? 36 : 24, '#FF4500');
            }
            drawScore();
            drawTime();
            drawCharacter();
            drawAnswerButtons();
            drawProgressBar();
        }

        function drawScore() { drawText(`分數：${score}`, 30, 60, canvas.width > 600 ? 24 : 18, '#FFFFFF', 'left'); }
        function drawTime() { const seconds = Math.floor(elapsedTime / 1000); drawText(`時間：${seconds} 秒`, canvas.width - 30, 60, canvas.width > 600 ? 24 : 18, '#FFFFFF', 'right'); }
        function drawCharacter() {
            const charWidth = canvas.width > 600 ? 150 : 100;
            const charHeight = (akitaImage.height / akitaImage.width) * charWidth;
            if (akitaImage && akitaImage.complete) {
                ctx.drawImage(akitaImage, canvas.width / 2 - charWidth / 2, canvas.height * 0.45 + characterYOffset - charHeight / 2, charWidth, charHeight);
            }
        }
        
        function drawAnswerButtons() {
            const cols = canvas.width > 700 ? 3 : 2;
            const btnWidth = 120;
            const btnHeight = 60;
            const totalWidth = cols * (btnWidth + 20) - 20;
            const startX = (canvas.width - totalWidth) / 2 + btnWidth / 2;
            const startY = canvas.height * 0.7;
            answerButtons.forEach((btn, index) => {
                const row = Math.floor(index / cols);
                const col = index % cols;
                const btnX = startX + col * (btnWidth + 20);
                const btnY = startY + row * (btnHeight + 20);
                drawButton(btn.value, btnX, btnY, btnWidth, btnHeight, '#FFD700', '#8B4513');
                btn.x = btnX; btn.y = btnY; btn.width = btnWidth; btn.height = btnHeight;
            });
        }

        function drawProgressBar() {
            const barWidth = canvas.width * 0.6;
            const barHeight = 25;
            const barX = (canvas.width - barWidth) / 2;
            const barY = canvas.height - 50;
            const maxQuestions = 20;
            ctx.fillStyle = '#f0e68c';
            ctx.beginPath(); ctx.roundRect(barX, barY, barWidth, barHeight, 12); ctx.fill();
            const progress = (correctAnswersCount / maxQuestions) * barWidth;
            if (progress > 0) {
                ctx.fillStyle = '#FFC107';
                ctx.beginPath(); ctx.roundRect(barX, barY, progress, barHeight, 12); ctx.fill();
            }
            ctx.strokeStyle = '#daa520';
            ctx.lineWidth = 3;
            ctx.beginPath(); ctx.roundRect(barX, barY, barWidth, barHeight, 12); ctx.stroke();
            drawText(`${correctAnswersCount} / ${maxQuestions}`, canvas.width / 2, barY + barHeight / 2, 16, '#A52A2A');
        }
        
        function drawGameOverPage() {
            drawPracticePage();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            const modalWidth = canvas.width * 0.7; const modalHeight = canvas.height * 0.6;
            const modalX = (canvas.width - modalWidth) / 2; const modalY = (canvas.height - modalHeight) / 2;
            ctx.fillStyle = '#FFF8DC'; ctx.strokeStyle = '#F0E68C'; ctx.lineWidth = 10;
            ctx.beginPath(); ctx.roundRect(modalX, modalY, modalWidth, modalHeight, 20); ctx.fill(); ctx.stroke();
            const totalTime = Math.floor(elapsedTime / 1000);
            drawText('挑戰完成！', canvas.width / 2, modalY + modalHeight * 0.2, 40, '#D2691E');
            drawText(`總分：${score}`, canvas.width / 2, modalY + modalHeight * 0.4, 30, '#8B4513');
            drawText(`總共花了 ${totalTime} 秒`, canvas.width / 2, modalY + modalHeight * 0.55, 30, '#8B4513');
            const btnWidth = 200; const btnHeight = 60;
            const btnX = canvas.width / 2; const btnY = modalY + modalHeight * 0.8;
            drawButton('儲存紀錄', btnX, btnY, btnWidth, btnHeight, '#28a745', '#FFFFFF');
            uiButtons = [{ id: 'save_score', x: btnX, y: btnY, width: btnWidth, height: btnHeight }];
        }

        function drawEnterNamePage() {
            drawGameOverPage(); // Show background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const modalWidth = canvas.width * 0.7; const modalHeight = canvas.height * 0.5;
            const modalX = (canvas.width - modalWidth) / 2; const modalY = (canvas.height - modalHeight) / 2;

            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath(); ctx.roundRect(modalX, modalY, modalWidth, modalHeight, 20); ctx.fill();

            drawText('請輸入你的名字', canvas.width/2, modalY + modalHeight * 0.2, 32, '#333');
            
            // Draw input box
            const inputWidth = modalWidth * 0.8; const inputHeight = 60;
            const inputX = (canvas.width - inputWidth) / 2; const inputY = modalY + modalHeight * 0.4;
            ctx.strokeStyle = '#CCC'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.roundRect(inputX, inputY, inputWidth, inputHeight, 10); ctx.stroke();
            
            // Draw player name with a blinking cursor
            let displayName = playerName;
            if (Math.floor(Date.now() / 500) % 2 === 0) {
                displayName += '|';
            }
            drawText(displayName, canvas.width/2, inputY + inputHeight/2, 28, '#000');
            
            const btnWidth = 200; const btnHeight = 60;
            const btnX = canvas.width/2; const btnY = modalY + modalHeight * 0.8;
            drawButton('確認', btnX, btnY, btnWidth, btnHeight, '#007bff', '#FFFFFF');
            uiButtons = [{ id: 'confirm_name', x: btnX, y: btnY, width: btnWidth, height: btnHeight }];
        }

        function drawLeaderboardPage() {
            const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grad.addColorStop(0, '#4e54c8'); grad.addColorStop(1, '#8f94fb');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawText('速度挑戰排行榜', canvas.width / 2, canvas.height * 0.1, 40, '#FFFFFF');

            if (isLeaderboardLoading) {
                drawText('讀取中...', canvas.width / 2, canvas.height / 2, 30, '#FFFFFF');
            } else if (!db) {
                drawText('排行榜功能暫時無法使用', canvas.width / 2, canvas.height / 2, 24, '#FFD700');
            } else {
                const startY = canvas.height * 0.2;
                const lineHeight = 40;
                drawText('排名', canvas.width * 0.2, startY, 20, '#FFD700');
                drawText('名字', canvas.width * 0.4, startY, 20, '#FFD700');
                drawText('分數', canvas.width * 0.6, startY, 20, '#FFD700');
                drawText('時間(秒)', canvas.width * 0.8, startY, 20, '#FFD700');

                leaderboardData.slice(0, 10).forEach((entry, index) => {
                    const y = startY + (index + 1) * lineHeight;
                    drawText(index + 1, canvas.width * 0.2, y, 18, '#FFFFFF');
                    drawText(entry.name, canvas.width * 0.4, y, 18, '#FFFFFF');
                    drawText(entry.score, canvas.width * 0.6, y, 18, '#FFFFFF');
                    drawText(entry.time, canvas.width * 0.8, y, 18, '#FFFFFF');
                });
            }

            const btnWidth = 200; const btnHeight = 60;
            const btnX = canvas.width/2; const btnY = canvas.height - 80;
            drawButton('返回首頁', btnX, btnY, btnWidth, btnHeight, '#6c757d', '#FFFFFF');
            uiButtons = [{ id: 'back_home', x: btnX, y: btnY, width: btnWidth, height: btnHeight }];
        }
        
        function drawButton(text, x, y, width, height, color, textColor) {
            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)'; ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 4; ctx.shadowOffsetY = 4;
            ctx.fillStyle = color;
            ctx.beginPath(); ctx.roundRect(x - width/2, y - height/2, width, height, 15); ctx.fill();
            ctx.restore();
            drawText(text, x, y, 22, textColor);
        }

        // --- Game Logic ---
        function startCharacterAnimation() {
            cancelAnimationFrame(animationFrameId);
            const jumpDuration = 1000, jumpHeight = 50;
            const animationStartTime = Date.now();
            function animate() {
                const elapsed = Date.now() - animationStartTime;
                const progress = elapsed / jumpDuration;
                if (progress < 1) {
                    characterYOffset = -Math.sin(progress * Math.PI) * jumpHeight;
                    drawScreen();
                    animationFrameId = requestAnimationFrame(animate);
                } else {
                    characterYOffset = 0;
                    drawScreen();
                }
            }
            animate();
        }

        function generateNewQuestion() {
            let num1, num2, newQuestion;
            do {
                if (questionRange === '混合') {
                    num1 = Math.floor(Math.random() * 10) + 1;
                    num2 = Math.floor(Math.random() * 9) + 1;
                } else {
                    num1 = questionRange;
                    num2 = Math.floor(Math.random() * 9) + 1;
                }
                newQuestion = { num1, num2 };
            } while (lastQuestion.num1 === newQuestion.num1 && lastQuestion.num2 === newQuestion.num2);
            const answer = num1 * num2;
            currentQuestion = { num1, num2, answer };
            lastQuestion = newQuestion;
            const wrongAnswers = new Set();
            while(wrongAnswers.size < 5) {
                let offset = Math.floor(Math.random() * 10) - 5;
                if (offset === 0) offset = 1;
                let wrongAnswer = answer + offset;
                if (wrongAnswer > 0 && wrongAnswer !== answer && !wrongAnswers.has(wrongAnswer)) {
                    wrongAnswers.add(wrongAnswer);
                }
            }
            answerButtons = [ { value: answer, correct: true }, ...Array.from(wrongAnswers).map(val => ({ value: val, correct: false })) ];
            answerButtons.sort(() => Math.random() - 0.5);
            feedbackMessage = '';
            drawScreen();
        }

        function checkAnswer(isCorrect) {
            isAnswerLocked = true; // Lock input at the beginning
            if (isCorrect) {
                feedbackMessage = '太棒了！答對囉！';
                correctAnswersCount++;
                score += 5;
                if(correctSynth) correctSynth.triggerAttackRelease(['C4', 'E4', 'G4'], '8n');
                startCharacterAnimation();
                setTimeout(() => {
                    if (correctAnswersCount >= 20) {
                        clearInterval(timerInterval);
                        currentPage = 'gameOver';
                        drawScreen();
                        // isAnswerLocked remains true as the page changes
                    } else {
                        generateNewQuestion();
                        isAnswerLocked = false; // Unlock for the next question
                    }
                }, 1500);
            } else {
                feedbackMessage = '再想想看喔！';
                score = Math.max(0, score - 2);
                if(wrongSynth) wrongSynth.triggerAttackRelease('C3', '4n');
                setTimeout(() => {
                    feedbackMessage = '';
                    drawScreen();
                    isAnswerLocked = false; // Unlock after feedback
                }, 1500);
            }
            drawScreen(); // Immediately update the screen with the feedback message
        }
        
        function resetGame() {
            currentPage = 'home';
            correctAnswersCount = 0;
            score = 0;
            startTime = 0;
            elapsedTime = 0;
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = null;
            feedbackMessage = '';
            lastQuestion = {};
            playerName = '';
            isAnswerLocked = false; // Reset the lock
            drawScreen();
        }

        // --- Firestore Logic ---
        async function saveScoreToLeaderboard(name, score, time) {
            if (!db) { console.error("Firestore is not initialized."); return; }
            try {
                const leaderboardCol = collection(db, `/artifacts/${appId}/public/data/leaderboard`);
                await addDoc(leaderboardCol, { name, score, time, createdAt: new Date() });
                console.log("Score saved successfully!");
            } catch (error) {
                console.error("Error saving score: ", error);
            }
        }

        async function fetchLeaderboard() {
            isLeaderboardLoading = true;
            drawScreen();

            if (!db) {
                console.warn("Firestore is not initialized. Leaderboard is disabled.");
                leaderboardData = [];
                isLeaderboardLoading = false;
                drawScreen();
                return;
            }

            try {
                const leaderboardCol = collection(db, `/artifacts/${appId}/public/data/leaderboard`);
                const snapshot = await getDocs(leaderboardCol);
                const scores = snapshot.docs.map(doc => doc.data());
                // Sort by score (desc), then time (asc)
                scores.sort((a, b) => b.score - a.score || a.time - b.time);
                leaderboardData = scores;
            } catch (error) {
                console.error("Error fetching leaderboard: ", error);
                leaderboardData = [];
            }
            isLeaderboardLoading = false;
            drawScreen();
        }
        
        // --- Audio Initialization ---
        async function initializeAudio() {
            if (audioInitialized) return;
            try {
                await Tone.start();
                correctSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.2 } }).toDestination();
                wrongSynth = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
                clickSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
                audioInitialized = true;
                console.log("Audio context started.");
            } catch (e) {
                console.error("Could not start audio context:", e);
            }
        }

        // --- Event Listeners ---
        function handleKeyPress(event) {
            if (currentPage !== 'enterName') return;
            if (event.key === 'Enter') {
                const confirmButton = uiButtons.find(btn => btn.id === 'confirm_name');
                if (confirmButton) {
                    canvas.dispatchEvent(new MouseEvent('click', {
                        clientX: confirmButton.x,
                        clientY: confirmButton.y,
                    }));
                }
            } else if (event.key === 'Backspace') {
                playerName = playerName.slice(0, -1);
            } else if (playerName.length < 10 && event.key.length === 1 && event.key.match(/[\w\d\s]/i)) {
                playerName += event.key;
            }
            drawScreen();
        }

        canvas.addEventListener('click', async function(event) {
            await initializeAudio();
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            if (currentPage === 'home' || currentPage === 'selection' || currentPage === 'gameOver' || currentPage === 'leaderboard' || currentPage === 'enterName') {
                uiButtons.forEach(async btn => {
                    if (mouseX > btn.x - btn.width/2 && mouseX < btn.x + btn.width/2 && mouseY > btn.y - btn.height/2 && mouseY < btn.y + btn.height/2) {
                        if (clickSynth) clickSynth.triggerAttackRelease('C5', '16n');
                        switch(btn.id) {
                            case 'start':
                                currentPage = 'selection';
                                drawScreen();
                                break;
                            case 'select':
                                isAnswerLocked = false; // Reset lock for new game
                                questionRange = btn.value; currentPage = 'practice';
                                correctAnswersCount = 0; score = 0; lastQuestion = {};
                                generateNewQuestion();
                                startTime = Date.now(); elapsedTime = 0;
                                if (timerInterval) clearInterval(timerInterval);
                                timerInterval = setInterval(() => {
                                    elapsedTime = Date.now() - startTime;
                                    if (currentPage === 'practice') { drawScreen(); }
                                }, 1000);
                                break;
                            case 'save_score':
                                currentPage = 'enterName';
                                drawScreen();
                                break;
                            case 'confirm_name':
                                if (playerName.trim()) {
                                    await saveScoreToLeaderboard(playerName, score, Math.floor(elapsedTime / 1000));
                                    currentPage = 'leaderboard';
                                    await fetchLeaderboard();
                                }
                                break;
                            case 'show_leaderboard':
                                currentPage = 'leaderboard';
                                await fetchLeaderboard();
                                break;
                            case 'back_home':
                                resetGame();
                                break;
                        }
                    }
                });
            } else if (currentPage === 'practice') {
                if(isAnswerLocked) return; // Prevent clicking if an answer is being processed
                answerButtons.forEach(btn => {
                    if (mouseX > btn.x - btn.width/2 && mouseX < btn.x + btn.width/2 && mouseY > btn.y - btn.height/2 && mouseY < btn.y + btn.height/2) {
                        checkAnswer(btn.correct);
                    }
                });
            }
        });

        // --- Main App Startup ---
        // *** 重要更新：將主程式包在 window.onload 中，確保所有資源 (如 Tone.js) 都已載入 ***
        window.onload = function() {
            async function main() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                drawSystemText('載入中...');

                // This is the primary change: We no longer await firebase here.
                // We just call it and let it run in the background.
                initializeFirebase(); 

                try {
                    // We only await assets that are critical for the initial render.
                    await loadAssets();
                    
                    // Once critical assets are ready, draw the main screen.
                    resizeCanvas();
                    window.addEventListener('resize', resizeCanvas, false);
                    window.addEventListener('keydown', handleKeyPress);
                    
                } catch (error) {
                    console.error("Asset loading failed:", error);
                    drawSystemText('遊戲圖片載入失敗', 'red');
                }
            }

            main();
        }

    </script>
</body>
</html>


