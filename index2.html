<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>九九乘法冒險島</title>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@700&display=swap" rel="stylesheet"/>
  <style>
    :root { --safe-bottom: env(safe-area-inset-bottom, 0px); }
    body { margin:0; overflow:hidden; background:#87ceeb; font-family:'M PLUS Rounded 1c', sans-serif; }
    canvas { display:block; }

    #nameInput {
      position: fixed;
      display: none;
      border: 2px solid #CCC;
      border-radius: 10px;
      background: #FFF;
      color: #000;
      font-weight: 700;
      text-align: center;
      outline: none;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      z-index: 9999;
      pointer-events: auto;
    }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <input
    id="nameInput"
    type="text"
    lang="zh-Hant"
    inputmode="text"
    autocomplete="off"
    autocapitalize="none"
    autocorrect="off"
    maxlength="10"
    placeholder="請在此輸入名字"
  />

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const nameInputEl = document.getElementById('nameInput');

    function rr(ctx, x, y, w, h, r = 0) {
      const radii = typeof r === 'number' ? {tl:r, tr:r, br:r, bl:r} : (r || {tl:0,tr:0,br:0,bl:0});
      ctx.beginPath();
      ctx.moveTo(x + radii.tl, y);
      ctx.lineTo(x + w - radii.tr, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radii.tr);
      ctx.lineTo(x + w, y + h - radii.br);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radii.br, y + h);
      ctx.lineTo(x + radii.bl, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radii.bl);
      ctx.lineTo(x, y + radii.tl);
      ctx.quadraticCurveTo(x, y, x + radii.tl, y);
      ctx.closePath();
    }
    function getSafeBottom() {
      const v = getComputedStyle(document.documentElement).getPropertyValue('--safe-bottom') || '0px';
      const n = parseFloat(v);
      return isNaN(n) ? 0 : n;
    }

    // --- Firebase 初始化 ---
    let db = null, auth = null;
    async function initializeFirebase() {
      try {
        const firebaseConfig = {
          apiKey: "AIzaSyDfIw36T88S3xlGCoAP9nDGCRkpQlWKiLE",
          authDomain: "ieka99.firebaseapp.com",
          projectId: "ieka99",
          storageBucket: "ieka99.appspot.com",
          messagingSenderId: "893665009867",
          appId: "1:893665009867:web:d732e15cf792890c8a7b4e"
        };
        firebase.initializeApp(firebaseConfig);
        auth = firebase.auth();
        db = firebase.firestore();
        try { await auth.signInAnonymously(); } catch(e){ db = null; }
      } catch(e) { db = null; }
    }

    // --- 遊戲狀態 ---
    let currentPage = 'home';
    let currentQuestion = {};
    let feedbackMessage = '';
    let correctAnswersCount = 0;
    let score = 0;
    let answerButtons = [];
    let uiButtons = [];
    let questionRange = 0;     // 題型：1~10 或 '混合'
    let lastQuestion = {};
    let playerName = '';
    let leaderboardData = [];
    let isLeaderboardLoading = false;
    let isAnswerLocked = false;

    // 篩選狀態（排行榜）
    const TYPE_ALL = '全部';
    const TYPE_UNTAGGED = '未標記';
    let leaderboardType = TYPE_ALL;

    // --- 動畫/音效/時間 ---
    let characterYOffset = 0;
    let isCharacterJumping = false;
    let jumpStartTime = 0;
    const JUMP_DURATION = 1000, JUMP_HEIGHT = 50;
    let feedbackEndTime = 0, lastAnswerWasCorrect = false;
    let startTime = 0, elapsedTime = 0;

    let correctSynth, wrongSynth, clickSynth;
    let audioInitialized = false;

    // --- 素材 ---
    let akitaImage, characterImage;
    function loadAssets() {
      return new Promise((resolve, reject) => {
        akitaImage = new Image();
        characterImage = new Image();
        akitaImage.src = '可愛秋田.png';
        characterImage.src = 'S876553.png';
        let loaded = 0;
        const done=()=>{ if(++loaded===2) resolve(); };
        akitaImage.onload = done; characterImage.onload = done;
        akitaImage.onerror = ()=>reject(new Error('akita load fail'));
        characterImage.onerror = ()=>reject(new Error('character load fail'));
        setTimeout(()=>reject(new Error('image timeout')), 8000);
      });
    }

    // --- 畫面繪製 ---
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (currentPage === 'enterName') positionNameInput();
    }

    function drawText(text, x, y, fontSize, color, align='center', baseline='middle') {
      ctx.font = `bold ${fontSize}px 'M PLUS Rounded 1c', sans-serif`;
      ctx.fillStyle = color;
      ctx.textAlign = align;
      ctx.textBaseline = baseline;
      ctx.shadowColor = 'rgba(0,0,0,0.2)';
      ctx.shadowBlur = 5; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2;
      ctx.fillText(text, x, y);
      ctx.shadowColor = 'transparent';
    }

    function drawSystemText(text, color='#333') {
      ctx.fillStyle="#fff"; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.font="bold 30px sans-serif"; ctx.fillStyle=color;
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(text, canvas.width/2, canvas.height/2);
    }

    function drawHomePage() {
      const g=ctx.createLinearGradient(0,0,0,canvas.height);
      g.addColorStop(0,'#87CEEB'); g.addColorStop(1,'#66CDAA');
      ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
      drawCloud(150,100,1); drawCloud(canvas.width-200,150,0.8);
      drawText('王公九九乘法冒險島', canvas.width/2, canvas.height*0.25, canvas.width>600?50:36, '#000080');
      drawText('等你來挑戰', canvas.width/2, canvas.height*0.35, canvas.width>600?24:18, '#000080');

      if (characterImage && characterImage.complete && characterImage.naturalWidth>0) {
        const w = canvas.width*0.15, h = (characterImage.naturalHeight/characterImage.naturalWidth)*w;
        ctx.drawImage(characterImage, canvas.width/2 - w/2, canvas.height/2 - h/2, w, h);
      }

      const bw=220,bh=70, y1=canvas.height*0.7, y2=y1+bh+20;
      drawButton('開始冒險！', canvas.width/2, y1, bw, bh, '#FF69B4', '#FFFFFF');
      drawButton('排行榜', canvas.width/2, y2, bw, bh, '#17a2b8', '#FFFFFF');
      uiButtons = [
        {id:'start', x:canvas.width/2, y:y1, width:bw, height:bh},
        {id:'show_leaderboard', x:canvas.width/2, y:y2, width:bw, height:bh}
      ];
      hideNameInput();
    }

    function drawCloud(x,y,s) {
      ctx.fillStyle='rgba(255,255,255,0.9)';
      ctx.beginPath(); ctx.arc(x,y,30*s,0,Math.PI*2);
      ctx.arc(x+35*s,y-10*s,40*s,0,Math.PI*2);
      ctx.arc(x+70*s,y,30*s,0,Math.PI*2);
      ctx.arc(x+35*s,y+15*s,40*s,0,Math.PI*2);
      ctx.closePath(); ctx.fill();
    }

    function drawSelectionPage() {
      const g=ctx.createLinearGradient(0,0,0,canvas.height);
      g.addColorStop(0,'#9ACD32'); g.addColorStop(1,'#FFD700');
      ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
      drawText('選擇你的乘法挑戰！', canvas.width/2, canvas.height*0.1, canvas.width>600?40:28, '#8B4513');

      uiButtons = [];
      const nums = [1,2,3,4,5,6,7,8,9,10,'混合'];
      const cols = canvas.width>800?4:3;
      const bw = Math.floor((canvas.width*0.8)/cols);
      const bh = 60;
      const spacingX = bw + 20, spacingY = bh + 20;
      const startX = (canvas.width - (cols*spacingX - 20))/2 + bw/2;
      const startY = canvas.height*0.25;

      nums.forEach((num, i)=>{
        const r = Math.floor(i/cols), c = i%cols;
        const x = startX + c*spacingX;
        const y = startY + r*spacingY;
        const label = (num==='混合') ? '混合' : `${num} 的乘法`;
        drawButton(label, x, y, bw, bh, '#4CAF50', '#FFFFFF');
        uiButtons.push({ id:'select', value:num, x, y, width:bw, height:bh });
      });
      hideNameInput();
    }

    function drawPracticePage() {
      const g=ctx.createLinearGradient(0,0,0,canvas.height);
      g.addColorStop(0,'#1E90FF'); g.addColorStop(1,'#87CEFA');
      ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);

      const bx=canvas.width/2, by=canvas.height*0.2, br=canvas.width>600?100:70;
      ctx.fillStyle='rgba(255,255,255,0.8)';
      ctx.beginPath(); ctx.arc(bx,by,br,0,Math.PI*2); ctx.fill();

      drawText(`${currentQuestion.num1} x ${currentQuestion.num2} = ?`, bx,by, canvas.width>600?48:36, '#000080');
      if (feedbackMessage) drawText(feedbackMessage, canvas.width/2, canvas.height*0.35, canvas.width>600?36:24, '#FF4500');

      drawScore(); drawTime(); drawCharacter();
      drawAnswerButtons();
      drawProgressBar();

      if (currentPage !== 'enterName') hideNameInput();
    }

    function drawScore(){ drawText(`分數：${score}`, 30, 60, canvas.width>600?24:18, '#FFFFFF','left'); }
    function drawTime(){ const s=Math.floor(elapsedTime/1000); drawText(`時間：${s} 秒`, canvas.width-30, 60, canvas.width>600?24:18, '#FFFFFF','right'); }

    function drawCharacter() {
      const w = canvas.width>600?150:100;
      const nw = (akitaImage&&akitaImage.naturalWidth)||0;
      const nh = (akitaImage&&akitaImage.naturalHeight)||0;
      if (akitaImage && akitaImage.complete && nw>0 && nh>0) {
        const h = (nh/nw)*w;
        ctx.drawImage(akitaImage, canvas.width/2 - w/2, canvas.height*0.45 + characterYOffset - h/2, w, h);
      }
    }

    function drawAnswerButtons() {
      const cols = canvas.width > 700 ? 3 : 2;
      const baseW = 120, baseH = 60, baseGap = 20;
      const rows = Math.ceil(answerButtons.length / cols);
      const barH = 25;
      const safeBottom = getSafeBottom();
      const bottomReserve = safeBottom + barH + 24;
      const availableBottomY = canvas.height - bottomReserve;
      const totalH = rows * baseH + (rows - 1) * baseGap;

      let top = availableBottomY - totalH - 10;
      const minTop = canvas.height * 0.52;

      let s = 1;
      if (top < minTop) {
        const avail = availableBottomY - 10 - minTop;
        const need = totalH;
        s = Math.max(0.6, Math.min(1, avail / need));
        const scaledTotalH = rows * (baseH * s) + (rows - 1) * (baseGap * s);
        top = availableBottomY - scaledTotalH - 10;
      }
      const bw = baseW * s, bh = baseH * s, gap = baseGap * s;
      const totalW = cols * bw + (cols - 1) * gap;
      const startX = (canvas.width - totalW) / 2 + bw / 2;
      const startY = top + bh / 2;

      answerButtons.forEach((btn, i) => {
        const r = Math.floor(i / cols);
        const c = i % cols;
        const x = startX + c * (bw + gap);
        const y = startY + r * (bh + gap);
        drawButton(btn.value, x, y, bw, bh, '#FFD700', '#8B4513');
        btn.x = x; btn.y = y; btn.width = bw; btn.height = bh;
      });
    }

    function drawProgressBar() {
      const barWidth = canvas.width * 0.6;
      const barHeight = 25;
      const safeBottom = getSafeBottom();
      const margin = 10;

      const barX = (canvas.width - barWidth) / 2;
      const barY = canvas.height - safeBottom - margin - barHeight;

      const maxQuestions = 20;
      ctx.fillStyle = '#f0e68c';
      rr(ctx, barX, barY, barWidth, barHeight, 12); ctx.fill();

      const progress = (correctAnswersCount / maxQuestions) * barWidth;
      if (progress > 0) {
        ctx.fillStyle = '#FFC107';
        rr(ctx, barX, barY, progress, barHeight, 12); ctx.fill();
      }

      ctx.strokeStyle = '#daa520';
      ctx.lineWidth = 3;
      rr(ctx, barX, barY, barWidth, barHeight, 12); ctx.stroke();

      drawText(`${correctAnswersCount} / ${maxQuestions}`, canvas.width / 2, barY + barHeight / 2, 16, '#A52A2A');
    }

    function drawGameOverPage() {
      drawPracticePage();
      ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      const mw=canvas.width*0.7, mh=canvas.height*0.6;
      const mx=(canvas.width-mw)/2, my=(canvas.height-mh)/2;
      ctx.fillStyle='#FFF8DC'; ctx.strokeStyle='#F0E68C'; ctx.lineWidth=10;
      rr(ctx,mx,my,mw,mh,20); ctx.fill(); ctx.stroke();
      const totalSec=Math.floor(elapsedTime/1000);
      drawText('挑戰完成！', canvas.width/2, my+mh*0.2, 40,'#D2691E');
      drawText(`總分：${score}`, canvas.width/2, my+mh*0.4, 30,'#8B4513');
      drawText(`總共花了 ${totalSec} 秒`, canvas.width/2, my+mh*0.55, 30,'#8B4513');
      const bw=200,bh=60,bx=canvas.width/2,by=my+mh*0.8;
      drawButton('儲存紀錄', bx,by,bw,bh,'#28a745','#FFFFFF');
      uiButtons=[{id:'save_score', x:bx, y:by, width:bw, height:bh}];
    }

    function drawEnterNamePage() {
      drawGameOverPage();
      ctx.fillStyle='rgba(0,0,0,0.8)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      const mw=canvas.width*0.7, mh=canvas.height*0.5;
      const mx=(canvas.width-mw)/2, my=(canvas.height-mh)/2;
      ctx.fillStyle='#fff'; rr(ctx,mx,my,mw,mh,20); ctx.fill();
      drawText('請輸入你的名字', canvas.width/2, my+mh*0.2, 32, '#333');

      const iw=mw*0.8, ih=60, ix=(canvas.width-iw)/2, iy=my+mh*0.4;
      ctx.strokeStyle='#CCC'; ctx.lineWidth=2; rr(ctx,ix,iy,iw,ih,10); ctx.stroke();

      const bw=200,bh=60,bx=canvas.width/2,by=my+mh*0.8;
      drawButton('確認', bx,by,bw,bh,'#007bff','#FFFFFF');
      uiButtons=[{id:'confirm_name', x:bx, y:by, width:bw, height:bh}];
    }

    // === 排行榜（含篩選） ===
    function drawLeaderboardPage() {
      const g=ctx.createLinearGradient(0,0,0,canvas.height);
      g.addColorStop(0,'#4e54c8'); g.addColorStop(1,'#8f94fb');
      ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
      drawText('速度挑戰排行榜', canvas.width/2, canvas.height*0.08, 40, '#fff');

      // 篩選籤（chips）
      const chips = [TYPE_ALL, ...Array.from({length:10}, (_,i)=>`${i+1} 的乘法`), '混合', TYPE_UNTAGGED];
      const chipY = canvas.height*0.16;
      const chipH = 36;
      let x = canvas.width*0.06;
      uiButtons = []; // 先清空，重新放入 chip 與底部按鈕

      chips.forEach((label)=>{
        const paddingX = 16;
        ctx.font = `bold 18px 'M PLUS Rounded 1c', sans-serif`;
        const textW = ctx.measureText(label).width;
        const w = Math.min(Math.max(textW + paddingX*2, 90), Math.min(canvas.width*0.4, 240));
        const h = chipH;
        const y = chipY;
        const isActive = (leaderboardType === label);

        // 背景
        ctx.save();
        ctx.shadowColor='rgba(0,0,0,0.2)'; ctx.shadowBlur=6; ctx.shadowOffsetX=2; ctx.shadowOffsetY=2;
        ctx.fillStyle = isActive ? '#FFD54F' : 'rgba(255,255,255,0.8)';
        rr(ctx, x, y - h/2, w, h, 18); ctx.fill();
        ctx.restore();

        // 文字
        ctx.fillStyle = isActive ? '#6A4A00' : '#333';
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(label, x + w/2, y);

        // 點擊區（用中心座標）
        uiButtons.push({ id:'filter_type', value:label, x: x + w/2, y: y, width: w, height: h });

        x += w + 12; // 下一個 chip 的起點
      });

      // 表頭
      const startY=canvas.height*0.25, lh=40;
      drawText('排名', canvas.width*0.15, startY, 20, '#FFD700');
      drawText('名字', canvas.width*0.35, startY, 20, '#FFD700');
      drawText('分數', canvas.width*0.55, startY, 20, '#FFD700');
      drawText('時間(秒)', canvas.width*0.75, startY, 20, '#FFD700');
      // 顯示類型
      drawText('類型', canvas.width*0.9, startY, 20, '#FFD700');

      // 內容
      if (isLeaderboardLoading) {
        drawText('讀取中...', canvas.width/2, canvas.height/2, 30, '#fff');
      } else if (!db) {
        drawText('排行榜功能暫時無法使用', canvas.width/2, canvas.height/2, 24, '#FFD700');
      } else {
        // 依目前篩選做 client-side 過濾（避免 Firestore 查「未標記」的限制）
        const filtered = leaderboardData.filter(e=>{
          const t = e.type; // 可能為 undefined
          if (leaderboardType === TYPE_ALL) return true;
          if (leaderboardType === TYPE_UNTAGGED) return (typeof t === 'undefined');
          return t === leaderboardType;
        });

        filtered.slice(0,10).forEach((e,i)=>{
          const y = startY + (i+1)*lh;
          drawText(i+1, canvas.width*0.15, y, 18, '#fff');
          drawText(e.name ?? '-', canvas.width*0.35, y, 18, '#fff');
          drawText(e.score ?? '-', canvas.width*0.55, y, 18, '#fff');
          drawText(e.time ?? '-', canvas.width*0.75, y, 18, '#fff');
          drawText(e.type ?? '未標記', canvas.width*0.9, y, 18, '#fff');
        });

        if (filtered.length === 0 && !isLeaderboardLoading) {
          drawText('（此類型目前沒有資料）', canvas.width/2, startY + lh*2, 18, '#fff');
        }
      }

      // 底部返回鍵
      const bw=200,bh=60,bx=canvas.width/2,by=canvas.height-80;
      drawButton('返回首頁', bx,by,bw,bh,'#6c757d','#fff');
      uiButtons.push({id:'back_home', x:bx, y:by, width:bw, height:bh});

      hideNameInput();
    }

    function drawButton(text, x,y,w,h, color, textColor) {
      ctx.save();
      ctx.shadowColor='rgba(0,0,0,0.3)'; ctx.shadowBlur=10; ctx.shadowOffsetX=4; ctx.shadowOffsetY=4;
      ctx.fillStyle=color; rr(ctx, x-w/2, y-h/2, w,h,15); ctx.fill();
      ctx.restore();
      drawText(text, x,y,Math.max(18, Math.min(22, w/6)), textColor);
    }

    // --- 名字輸入框定位 ---
    function computeEnterNameGeom() {
      const mw=canvas.width*0.7, mh=canvas.height*0.5;
      const mx=(canvas.width-mw)/2, my=(canvas.height-mh)/2;
      const iw=mw*0.8, ih=60, ix=(canvas.width-iw)/2, iy=my+mh*0.4;
      return { ix, iy, iw, ih };
    }
    function positionNameInput(geom) {
      const { ix, iy, iw, ih } = geom || computeEnterNameGeom();
      nameInputEl.style.left = `${Math.round(ix)}px`;
      nameInputEl.style.top  = `${Math.round(iy)}px`;
      nameInputEl.style.width  = `${Math.round(iw)}px`;
      nameInputEl.style.height = `${Math.round(ih)}px`;
      nameInputEl.style.fontSize = `${Math.max(22, Math.min(28, Math.round(ih*0.5)))}px`;
      nameInputEl.style.lineHeight = `${Math.round(ih)}px`;
    }
    function showNameInput() {
      nameInputEl.style.display = 'block';
      nameInputEl.value = playerName;
      requestAnimationFrame(()=> {
        nameInputEl.focus({ preventScroll: true });
        const len = nameInputEl.value.length;
        nameInputEl.setSelectionRange(len, len);
      });
    }
    function hideNameInput() {
      nameInputEl.style.display = 'none';
      if (document.activeElement === nameInputEl) nameInputEl.blur();
    }

    // --- 中文輸入組字處理 ---
    let isComposing = false;
    nameInputEl.addEventListener('compositionstart', () => { isComposing = true; });
    nameInputEl.addEventListener('compositionend', () => {
      isComposing = false;
      playerName = (nameInputEl.value || '').slice(0, 10);
    });
    nameInputEl.addEventListener('input', () => {
      if (isComposing) return;
      playerName = (nameInputEl.value || '').slice(0, 10);
    });
    nameInputEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        clickConfirmName();
      }
    });
    nameInputEl.addEventListener('click', (e)=>e.stopPropagation());

    // --- 角色跳躍 ---
    function startCharacterAnimation(){
      if (isCharacterJumping) return;
      isCharacterJumping = true; jumpStartTime = Date.now();
    }

    // --- 出題與作答 ---
    function generateWrongAnswers(answer, count=5) {
      const set = new Set();
      for (let off = -9; off <= 9 && set.size < count; off++) {
        if (off === 0) continue;
        const v = answer + off;
        if (v > 0) set.add(v);
      }
      let tries = 0;
      const upper = Math.max(answer + 20, 30);
      while (set.size < count && tries < 500) {
        const v = Math.floor(Math.random() * upper) + 1;
        if (v !== answer) set.add(v);
        tries++;
      }
      return Array.from(set).slice(0, count);
    }

    function generateNewQuestion() {
      let num1, num2, nq;
      do {
        if (questionRange==='混合') {
          num1 = Math.floor(Math.random()*10)+1;
          num2 = Math.floor(Math.random()*9)+1;
        } else {
          num1 = questionRange;
          num2 = Math.floor(Math.random()*9)+1;
        }
        nq = {num1,num2};
      } while (lastQuestion.num1===nq.num1 && lastQuestion.num2===nq.num2);
      const answer = num1*num2;
      currentQuestion = {num1,num2,answer};
      lastQuestion = nq;

      const wrongs = generateWrongAnswers(answer, 5);
      answerButtons = [{value:answer, correct:true}, ...wrongs.map(v=>({value:v, correct:false}))];
      answerButtons.sort(()=>Math.random()-0.5);
      feedbackMessage = '';
    }

    function checkAnswer(isCorrect){
      if (isAnswerLocked) return;
      isAnswerLocked = true;
      lastAnswerWasCorrect = isCorrect;

      if (isCorrect){
        feedbackMessage = '太棒了！答對囉！';
        correctAnswersCount++;
        score += 5;
        if (correctSynth) correctSynth.triggerAttackRelease(['C4','E4','G4'],'8n');
        startCharacterAnimation();
      } else {
        feedbackMessage = '再想想看喔！';
        score = Math.max(0, score - 2);
        if (wrongSynth) wrongSynth.triggerAttackRelease('C3','4n');
      }
      feedbackEndTime = Date.now() + 1500;
    }

    function resetGame(){
      currentPage='home';
      correctAnswersCount=0; score=0;
      startTime=0; elapsedTime=0;
      feedbackMessage=''; lastQuestion={};
      playerName=''; isAnswerLocked=false;
      hideNameInput();
    }

    // --- 儲存成績：含 type 欄位 ---
    async function saveScoreToLeaderboard(name, score, time) {
      if (!db) return;
      try {
        const type =
          (questionRange === '混合')
            ? '混合'
            : `${questionRange} 的乘法`;

        await db.collection('leaderboard').add({
          name,
          score,
          time,
          type,              // ← 新增：記錄是哪一個測驗
          createdAt: new Date()
        });
      } catch (e) {
        // 可選：console.log(e);
      }
    }

    // --- 讀取排行榜（一次抓全量，前端做篩選，避免「未標記」無法直接查詢的限制） ---
    async function fetchLeaderboard(){
      isLeaderboardLoading = true;
      if (!db) { leaderboardData=[]; isLeaderboardLoading=false; return; }
      try{
        const snap = await db.collection('leaderboard').get();
        const scores = snap.docs.map(d=>d.data());
        // 排序：分數高在前、時間短在前、若都有再按建立時間新在前（若有）
        scores.sort((a,b)=> (b.score - a.score) || (a.time - b.time) || ((b.createdAt?.seconds ?? 0) - (a.createdAt?.seconds ?? 0)));
        leaderboardData = scores;
      } catch { leaderboardData=[]; }
      isLeaderboardLoading = false;
    }

    // --- 音效 ---
    function initializeAudio(){
      if (audioInitialized || typeof Tone==='undefined') return;
      Tone.start().then(()=>{
        correctSynth = new Tone.PolySynth(Tone.Synth,{oscillator:{type:'sine'}, envelope:{attack:0.01,decay:0.1,sustain:0.2,release:0.2}}).toDestination();
        wrongSynth   = new Tone.Synth({oscillator:{type:'square'}, envelope:{attack:0.01,decay:0.2,sustain:0.1,release:0.2}}).toDestination();
        clickSynth   = new Tone.Synth({oscillator:{type:'triangle'}, envelope:{attack:0.005,decay:0.1,sustain:0,release:0.1}}).toDestination();
        audioInitialized = true;
      }).catch(()=>{});
    }

    // --- 鍵盤事件 ---
    function handleKeyPress(e){
      if (currentPage !== 'enterName') return;
      if (document.activeElement === nameInputEl) {
        if (e.key === 'Enter') { e.preventDefault(); clickConfirmName(); }
        return;
      }
      if (e.key === 'Enter') clickConfirmName();
    }

    // --- 滑鼠點擊 ---
    canvas.addEventListener('click', (event)=>{
      initializeAudio();
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const mouseX = (event.clientX - rect.left) * scaleX;
      const mouseY = (event.clientY - rect.top)  * scaleY;

      const hit = (b) => (mouseX > b.x - b.width/2 && mouseX < b.x + b.width/2 &&
                          mouseY > b.y - b.height/2 && mouseY < b.y + b.height/2);

      if (['home','selection','gameOver','leaderboard','enterName'].includes(currentPage)) {
        for (const btn of uiButtons) {
          if (hit(btn)) {
            if (clickSynth) clickSynth.triggerAttackRelease('C5','16n');
            switch(btn.id){
              case 'start':
                currentPage='selection'; break;
              case 'select':
                isAnswerLocked=false;
                questionRange=btn.value; currentPage='practice';
                correctAnswersCount=0; score=0; lastQuestion={};
                generateNewQuestion(); startTime=Date.now();
                break;
              case 'save_score':
                currentPage='enterName';
                positionNameInput();   // 切換頁面時定位一次
                showNameInput();       // 切換頁面時顯示+focus 一次
                break;
              case 'confirm_name':
                clickConfirmName(); break;
              case 'show_leaderboard':
                currentPage='leaderboard';
                leaderboardType = TYPE_ALL;          // 每次進排行榜，預設顯示全部
                isLeaderboardLoading=true; fetchLeaderboard();
                break;
              case 'filter_type':
                // 切換篩選類型
                leaderboardType = btn.value;
                break;
              case 'back_home':
                resetGame(); break;
            }
            break;
          }
        }
      } else if (currentPage==='practice') {
        if (isAnswerLocked) return;
        for (const btn of answerButtons) {
          if (hit(btn)) { checkAnswer(btn.correct); break; }
        }
      }
    });

    function clickConfirmName(){
      if (!playerName || !playerName.trim()) {
        if (currentPage==='enterName') {
          positionNameInput();
          showNameInput();
        }
        return;
      }
      currentPage='leaderboard'; isLeaderboardLoading=true;
      hideNameInput();
      Promise.resolve().then(async ()=>{
        await saveScoreToLeaderboard(playerName.trim(), score, Math.floor(elapsedTime/1000));
        await fetchLeaderboard();
      });
    }

    // --- 主循環 ---
    function drawScreen(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      switch(currentPage){
        case 'home': drawHomePage(); break;
        case 'selection': drawSelectionPage(); break;
        case 'practice': drawPracticePage(); break;
        case 'gameOver': drawGameOverPage(); break;
        case 'enterName': drawEnterNamePage(); break;
        case 'leaderboard': drawLeaderboardPage(); break;
      }
    }

    function gameLoop(){
      try{
        const now = Date.now();
        if (currentPage==='practice' && startTime>0) elapsedTime = now - startTime;

        if (isCharacterJumping){
          const ej = now - jumpStartTime;
          if (ej < JUMP_DURATION) {
            const p = ej / JUMP_DURATION;
            characterYOffset = -Math.sin(p*Math.PI)*JUMP_HEIGHT;
          } else { isCharacterJumping=false; characterYOffset=0; }
        }

        if (feedbackEndTime>0 && now>=feedbackEndTime){
          feedbackEndTime=0;
          if (lastAnswerWasCorrect){
            if (correctAnswersCount>=20) currentPage='gameOver';
            else { generateNewQuestion(); isAnswerLocked=false; }
          } else {
            feedbackMessage=''; isAnswerLocked=false;
          }
        }
        drawScreen();
      } catch(e){ /* 單幀錯誤不影響整體 */ }
      requestAnimationFrame(gameLoop);
    }

    window.onload = async function() {
      resizeCanvas();
      drawSystemText('載入中...');
      initializeFirebase();
      try{
        await loadAssets();
        window.addEventListener('resize', resizeCanvas, false);
        window.addEventListener('keydown', handleKeyPress);
        requestAnimationFrame(gameLoop);
      }catch{
        drawSystemText('遊戲圖片載入失敗', 'red');
      }
    };
  </script>
</body>
</html>
